#!/bin/bash

readonly BTORDIR=$(dirname "$(readlink -f $0)")
readonly RUNFUZZSMT=$BTORDIR/runfuzzsmt
readonly THREAD_TMP_FILE="/tmp/runparfuzzsmt$$_"
readonly MAX_THREADS=$(grep -c processor /proc/cpuinfo)

die ()
{
  echo "*** $(basename $0): $*" 1>&2
  usage
  exit 1
}

delete-tmp-files ()
{
  for file in ${files[@]}; do
    rm -f $file 
  done
}

collect-stats ()
{
  num_runs=0
  num_bugs=0
  for file in ${files[@]}; do
    ((num_bugs += $(grep -c bug $file)))
    runs=$(grep runs $file | tr '\r' '\n' | grep runs | tail -n1 | \
	   awk '{print $2}')
    ((num_runs += runs))
  done

  echo "host: $(hostname)"
  echo "threads: $threads"
  echo "bugs found: $num_bugs"
  echo "total runs: $num_runs"
}

cleanup-and-exit ()
{
  kill $(jobs -p) 2> /dev/null
  wait $(jobs -p)
  collect-stats
  delete-tmp-files
  exit
}

usage ()
{
  echo -n  "usage: $(basename $0) "
  echo -en "[<option>|<runfuzzsmt_options>|<fuzzsmt_option>] <command>"
  echo
  echo     "  options:"
  echo     "    -h,--help        print this message and exit"
  echo     "    --max-time=<val> time limit per thread in seconds"
  echo     "    --threads=<val>  min. 1, max. $MAX_THREADS"
  echo
  echo     "  runfuzzsmt_options: see runfuzzsmt -h"
  echo     "  fuzzsmt_options:   see fuzzsmt -h"
  echo
}

trap "cleanup-and-exit;" SIGHUP SIGINT SIGTERM

maxtime=0
threads=1
opts=""
while [ $# -gt 0 ]
do
  case $1 in
    -h|--help) usage
               exit
               ;;
    --max-time=*) maxtime=$(echo "$1" | sed -e 's,^--max-time=,,')
		  ;;
    --threads=*) threads=$(echo "$1" | sed -e 's,^--threads=,,')
		 ;;
    --max-threads) threads=$MAX_THREADS
		   ;;
    -*|[0-9]*) opts="$opts $1"
               ;;
    *) break;;
  esac
  shift
done

cmd="$*"
[ x"$cmd" = x ] && die "command missing"

if ((threads <= 0 || threads > MAX_THREADS)); then
  echo "invalid value for --threads: $threads"
  exit
fi

for ((i = 0; i < threads; i++)); do
  files[$i]=$THREAD_TMP_FILE$i
  if ((maxtime > 0)); then
    ((maxtime_kill = maxtime + 10))
    timeout -s SIGTERM -k $maxtime_kill $maxtime \
      $RUNFUZZSMT $opts $cmd > ${files[$i]} 2> /dev/null &
  else
    $RUNFUZZSMT $opts $cmd > ${files[$i]} 2> /dev/null &
  fi
  children="$children $!"
done

# wait for all spawned subprocesses
wait $children
cleanup-and-exit
