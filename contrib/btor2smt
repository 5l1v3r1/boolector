#!/usr/bin/env python
import sys, string, getopt

# NOTE: This script converts from BTOR to SMT format. It does NOT 
# perform all necessary syntax checks and does NOT support all BTOR operators. 
# Currently, overflow, reduction and rotation operators are not supported 
# Use Boolector to perform a syntax check for the BTOR file 
# before running this script. 

################################################################################
# This script assumes that its input is syntactically valid BTOR               #
################################################################################

class VarNode:
  def __init__(self, bw, name):
    assert (bw > 0)
    self.bw = bw
    self.name = name

class ArrayNode:
  def __init__(self, index_bw, elem_bw, name):
    assert (index_bw > 0)
    assert (elem_bw > 0)
    self.index_bw = index_bw
    self.elem_bw = elem_bw
    self.name = name

def usage ():
  print "usage: btor2smt [-n name] [-C <comment-file>] [-s|-u] [-c|-i] [-h]"

# dictonaries for bit-vector and array variables
vars = {}
arrays = {}

# other variables
comment_file_name = ""
category = ""
status = "unknown"
declaration = True
line_nr = 0
var_name_counter = 0
par_counter = 0
found_root = False
bench_name = "smt2btor"

try:
  opts, args = getopt.getopt(sys.argv[1:], "n:C:sucih")
except getopt.GetoptError, err:
  print str(err)
  usage()
  sys.exit(1)

for o, a in opts:
  if o in ("-h"):
    usage()
    sys.exit(0)
  elif o in ("-n"):
    bench_name = a
  elif o in ("-C"):
    include_comment = True
    comment_file_name = a
  elif o in ("-i"):
    category = "industrial"
  elif o in ("-c"):
    category = "crafted"
  elif o in ("-s"):
    status = "sat"
  elif o in ("-u"):
    status = "unsat"

def log2 (x):
  result = 0 
  assert (x > 0)
  while (x > 1):
    x >>= 1
    result += 1
  assert (result > 0)
  return result

def get_operand (id):
  idneg = False
  idint = int (id)

  if (idint < 0):
    idint = -idint
    idneg = True

  if str(idint) in vars:
    result = vars[str(idint)].name
  elif str(idint) in arrays:
    result = arrays[str(idint)].name
  else:
    result = "?e" + str(idint)

  if idneg:
    result = "(bvnot " + result + ")"
  return result

# read from stdin
for line in sys.stdin:
  line_nr += 1;

  #ignore comments
  if line.startswith(";"):
    continue

  words = string.split(line)
  if len(words) < 3:
    print >>sys.stderr, str(line_nr) + ": syntax error"
    sys.exit(1) 
  id = words[0]
  op = words[1]
  bw = words[2]

  if op == "root" and found_root:
    print str(line_nr) + ": root must be at the end of input"

  # note that python does not support switch
  if op == "var":
    if not declaration:
      print "variables and arrays must be declared before any other operation"
      sys.exit (1)
    if len(words) == 4:
      name = words[3]
    else:
      var_name_counter += 1
      name = "v" + str(var_name_counter) 
    if id in vars:
      print >>sys.stderr, str(line_nr) + ": redeclaration of variable"
      sys.exit (1)
    vars[id] = VarNode (bw, name)
  elif op == "array":
    if not declaration:
      print "variables and arrays must be declared before any other operation"
      sys.exit (1)
    index_bw = words[3]
    if id in arrays:
      print >>sys.stderr, str(line_nr) + ": redeclaration of array variable"
      sys.exit (1)
    name = "a" + str(len(arrays) + 1)
    arrays[id] = ArrayNode (index_bw, bw, name)
  else: 
    # write preamble
    if declaration:
      declaration = False

      print "(benchmark " + bench_name

      if comment_file_name != "":
	print ":source {"
	try:
	  comment_file = open(comment_file_name, 'r')
	  for line in comment_file:
	    line = line.rstrip("\n")
	    print line
	  print "}"
	except Exception, e:
	  print >>sys.stderr, "could not read comment file"
	  sys.exit (1)
        comment_file.close ()

      assert (status == "sat" or status == "unsat" or status == "unknown")
      print ":status " + status

      if category != "":
        assert (category == "crafted" or category == "industrial")
        print ":category { " + category + " }"

      if len(arrays) != 0:
	print ":logic QF_AUFBV"
      else:
	print ":logic QF_BV"

      for val in vars.itervalues():
	print ":extrafuns ((" + val.name + " BitVec[" + val.bw + "]))"
      for val in arrays.itervalues():
	print ":extrafuns ((" + val.name + " Array[" + val.index_bw + ":" + \
	      val.elem_bw + "]))"
      print ":formula"

    # constant declarations
    if op == "const":
      if int(bw) != len(words[3]):
	print >>sys.stderr, str(line_nr) + ": syntax error"
	sys.exit (1)
      try:
	val = int(words[3], 2)
      except Exception, e:
	print >>sys.stderr, str(line_nr) + ": syntax error"
	sys.exit (1)
      print "(let (?e" + id + " bv" + str(val) + "[" + bw + "])"
    elif op == "consth":
      try:
	val = int(words[3], 16)
      except Exception, e:
	print >>sys.stderr, str(line_nr) + ": syntax error"
	sys.exit (1)
      print "(let (?e" + id + " bv" + str(val) + "[" + bw + "])"
    elif op == "constd":
      print "(let (?e" + id + " bv" + words[3] + "[" + bw + "])"
    elif op == "zero":
      print "(let (?e" + id + " bv0[" + bw + "])"
    elif op == "one":
      print "(let (?e" + id + " bv1[" + bw + "])"
    elif op == "ones":
      print "(let (?e" + id + " (bvnot bv0[" + bw + "]))"
    # regular unary operators bit-vector operators
    elif op == "not" or op == "neg":
      op1 = get_operand (words[3])
      print "(let (?e" + id + " (bv" + op + " " + op1 + "))"
    # inc
    elif op == "inc":
      op1 = get_operand (words[3])
      print "(let (?e" + id + " (bvadd " + op1 + " bv1[" + bw + "]))"
    # dec 
    elif op == "dec":
      op1 = get_operand (words[3])
      print "(let (?e" + id + " (bvsub " + op1 + " bv1[" + bw + "]))"
    elif op == "slice":
      op1 = get_operand (words[3])
      print "(let (?e" + id + " (extract[" + words[4] + ":" + words[5] + \
            "] " + op1 + "))"
    elif op == "uext":
      op1 = get_operand (words[3])
      print "(let (?e" + id + " (zero_extend[" + words[4] + "] " + op1 + "))"
    elif op == "sext":
      op1 = get_operand (words[3])
      print "(let (?e" + id + " (sign_extend[" + words[4] + "] " + op1 + "))"
    # regular binary bit-vector operators
    elif op == "and" or op == "nand" or op == "or" or op == "nor" or \
	 op == "xor" or op == "xnor" or op == "add" or op == "sub" or \
	 op == "mul" or op == "udiv" or op == "sdiv" or op == "urem" or \
	 op == "srem" or op == "smod":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      print "(let (?e" + id + " (bv" + op + " " + op1 + " " + op2 + "))"
    # concat
    elif op == "concat":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      print "(let (?e" + id + " (concat " + op1 + " " + op2 + "))"
    # bit-vector predicates 
    elif op == "ult" or op == "ulte" or op == "ugt" or op == "ugte" or \
	 op == "slt" or op == "slte" or op == "sgt" or op == "sgte":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      if len(op) == 4:
	op_a = op.replace("t", "")
      else:
        op_a = op
      print "(let (?e" + id + " (ite (bv" + op_a + " " + op1 + " " + op2 + \
            ")" + " bv1[1] bv0[1]))"
    # iff, =
    elif op == "eq" or op == "iff":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      print "(let (?e" + id + " (ite (= " + op1 + " " + op2 + ") " + \
            "bv1[1] bv0[1]))"
    # ne
    elif op == "ne":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      print "(let (?e" + id + " (ite (not (= " + op1 + " " + op2 + ")) " + \
            "bv1[1] bv0[1]))"
    # implies
    elif op == "implies":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      print "(let (?e" + id + " (bvor (bvnot " + op1 +") " + op2 + "))"
    # shift operators
    elif op == "sll" or op == "srl" or op == "sra":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      bwext = str (int(bw) - log2 (int(bw)))
      if op == "sll":
	op_a = "bvshl"
      elif op == "srl":
        op_a = "bvlshr"
      else:
        assert (op == "sra")
        op_a = "bvashr"
      print "(let (?e" + id + " (" + op_a + " " + op1 + " (zero_extend[" + \
	    bwext + "] " + op2 +")))"
    # cond 
    elif op == "cond" or op == "acond":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      op3 = get_operand (words[5])
      print "(let (?e" + id + " (ite (= bv1[1] " + op1 + ") " + \
	    op2 + " " + op3 + "))"
    # read
    elif op == "read":
      op1 = get_operand (words[3])
      op2 = get_operand (words[4])
      print "(let (?e" + id + " (select " + op1 + " " + op2 + "))"
    # write 
    elif op == "write":
      op1 = get_operand (words[4])
      op2 = get_operand (words[5])
      op3 = get_operand (words[6])
      print "(let (?e" + id + " (store " + op1 + " " + op2 + " " + op3 + "))"
    # root
    elif op == "root":
      if found_root:
        print str(line_nr) + ": only one root supported"
	sys.exit (1)
      found_root = True
      op1 = get_operand (words[3])
      print "(not (= " + op1 + " bv0[1]))"

    else:
      print >>sys.stderr, str(line_nr) + ": unsupported operator: " + op 
      sys.exit (1)

    par_counter += 1 

# close parentheses
par_string = ""
for i in range (par_counter):       
  par_string = par_string + ")"
print par_string
