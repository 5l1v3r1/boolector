#!/bin/bash

# ATTENTION: we use btorold2new filter as workaround for btorgen

readonly usage="*** testbtorbtorgen: usage: ./testbtorbtorgen [-i <id>] [-c <limit> [-n]]" 
readonly covdir="./covtests/"
readonly valgrindcheck=100 # every nth testcase we check with valgrind
readonly file="/tmp/testbtorbtorgen$$.btor"
readonly filedump="/tmp/testbtorbtorgen$$dump.btor"
readonly filetmp="/tmp/testbtorbtorgen$$.tmp"
readonly filecovhashes="./testbtorbtorgenhashes"
readonly stdoutput="/tmp/testbtorbtorgen$$boolectorstdout.tmp"

function cleanup
{
  rm -f "$file"
  rm -f "$filedump"
  rm -f "$filetmp"
  rm -f "$filecovhashes"
  rm -f "$stdoutput"
}

trap 'cleanup; exit 0' SIGHUP SIGINT SIGTERM

btorgen=unknown
for d in `echo $PATH | sed -e 's,:, ,g'` .
do
  tmpfile=$d/btorgen
  [ -d "$d" ] || continue
  [ -f "$tmpfile" ] || continue
  btorgen=$tmpfile
  break
done
if [[ "$btorgen" = unknown ]]; then
  echo "*** testbtorbtorgen: can not find 'btorgen'" 1>&2
  exit 1
fi

btorgenjava=unknown
for d in `echo $PATH | sed -e 's,:, ,g'` .
do
  tmpfile=$d/btorgenjava
  [ -d "$d" ] || continue
  [ -f "$tmpfile" ] || continue
  btorgenjava=$tmpfile
  break
done
if [[ "$btorgenjava" = unknown ]]; then
  echo "*** testbtorbtorgen: can not find 'btorgenjava'" 1>&2
  exit 1
fi

i=0
counter=0
last=btorgenjava
cov=0
covlimit=0
id=1
covtestcounter=0
covcleanup=1

while getopts "i:c:n" o
do
  case "$o" in
  i)	id=$OPTARG;;
  c)	cov=1; covlimit=$OPTARG;;
  n)	covcleanup=0;;
  [?])	echo "$usage" 1>&2; exit 1;;
  esac
done

fileerror="error${id}.btor"

if [[ "$cov" -eq 1 ]]; then
  if [[ "$covlimit" -lt 1 ]]; then
    echo "Coverage limit must be positive" 1>&2
    exit 1
  fi

  if [[ "$covcleanup" -eq 1 ]]; then
    rm -r -f "$covdir"
    mkdir "$covdir"
    if [[ ! -e "$covdir" ]] || [[ ! -d "$covdir" ]] || \
       [[ ! -r "$covdir" ]] || [[ ! -w "$covdir" ]]; then
      echo "IO error"
      exit 1
    fi

    rm -f "$filecovhashes"
    touch "$filecovhashes"
  fi
fi


while true 
do 
  ((i++))
  ((counter++))

  randomnumber=$RANDOM
  ((randomnumber &= 1))
  if [[ "$randomnumber" -eq 0 ]]; then
    uamode=uag
  else
    uamode=ual
  fi

  randomnumber=$RANDOM
  ((randomnumber &= 1))
  if [[ "$randomnumber" -eq 0 ]]; then
    uabwref=uad
  else
    uabwref=uai
  fi

  randomnumber=$RANDOM
  ((randomnumber %= 3))
  if [[ "$randomnumber" -eq 0 ]]; then
    uaenc=uaz
  elif [[ "$randomnumber" -eq 1 ]]; then
    uaenc=uao
  else
    uaenc=uas
  fi

  uarwl=$RANDOM
  ((uarwl &= 3))

  # when we create coverage tests,
  # we do not want to generate models
  checkmodel=$RANDOM
  ((checkmodel = checkmodel & 1 & !cov))

  if [[ "$last" = "btorgen" ]]; then
    btorgenjava 2> /dev/null | sed -e 's,nego,redxor,g' | btorold2new > "$file"
    last=btorgenjava
  else
    btorgen 2> /dev/null | btorold2new > "$file"
    last=btorgen
  fi

  if [[ ! -s "$file" ]]; then
    echo "*** testbtorbtorgen: generated file is empty"
    cleanup
    exit 1
  fi 

  for rwl in 3 2 1 0
  do
    echo -n "Test $i rwl$rwl: "

    callstring="-rwl$rwl $file"
    if [[ "$uarwl" -eq 3 ]]; then
      callstring="$callstring -$uamode -$uabwref -$uaenc"
    fi
    if [[ "$checkmodel" -eq 1 ]]; then
      callstring="$callstring -m"
    fi

    if [[ "$cov" -eq 1 ]]; then
      covbase=${covdir}cov_id${id}_test$covtestcounter
      stderror=${covbase}.err
    else
     stderror=/dev/null
    fi
      
    echo $callstring
    boolector $callstring 1> "$stdoutput" 2> "$stderror"
    retval=$?
    cat "$stdoutput" | head -n 1
    if [[ "$rwl" -eq 3 ]]; then 
      goldenretval=$retval
      if [[ "$goldenretval" -ne 2 ]] && [[ "$goldenretval" -ne 3 ]]; then
	echo "ERROR"
	cp "$file" "$fileerror"
	echo "; error: $callstring" >> "$fileerror"
	cleanup
	exit 1
      fi
    else
      if [[ "$retval" -ne "$goldenretval" ]]; then
	echo "ERROR"
	cp "$file" "$fileerror"
	echo "; error: $callstring" >> "$fileerror"
	cleanup
	exit 1
      fi
    fi 

    if [[ "$cov" -eq 1 ]]; then
      if [[ ! -s "$stderror" ]]; then
	rm "$stderror"
      else
        cat "$stderror" | sort | uniq > "$filetmp"
	hashsum=`md5sum "$filetmp"`
        # synchronization for parallel usage
	( flock -x 200 
	  numcovtests=`cat "$filecovhashes" | wc -l`
	  if [[ "$numcovtests" -eq "$covlimit" ]]; then
	    exit 2
	  fi
	  if [[ `grep -c "^$hashsum" "$filecovhashes"` -eq 0 ]]; then
	    echo "$hashsum" >> "$filecovhashes"
	    exit 1
	  else
	    exit 0
	  fi 
	) 200> /var/lock/testbtorbtorgenlock
	returnval=$?

	if [[ "$returnval" -eq 2 ]]; then
	  if [[ "$covcleanup" -eq 1 ]]; then
	    cleanup
	  fi
	  rm "$stderror"
	  exit 0
	fi

	if [[ "$returnval" -eq 1 ]]; then
	  cp "$filetmp" "$stderror"
	  callfile=${covbase}.cs
	  covtestfile=${covbase}.btor
	  echo ${callstring/" $file"/""} > "$callfile"
	  cp "$file" "$covtestfile"
	  ((covtestcounter++))
	else
	  rm "$stderror"
	fi
      fi
    fi

  done

  echo -n "Test $i dump: "
  boolector "$file" -de 1> "$filedump" 2> /dev/null
  boolector "$filedump" 2> /dev/null
  retval=$?
  if [[ "$retval" -ne "$goldenretval" ]]; then
    echo "ERROR"
    cp "$file" "$fileerror"
    echo "; dump error" >> "$fileerror"
    cleanup
    exit 1
  fi 

  if [[ "$checkmodel" -eq 1 ]] && [[ "$retval" -eq 2 ]]; then
    btorcheckmodel "$file" "$stdoutput"
    retval=$?
    if [[ "$retval" -ne 0 ]]; then
      echo "ERROR"
      cp "$file" "$fileerror"
      cp "$stdoutput" "${fileerror}.model"
      echo "; error: $callstring" >> "$fileerror"
      cleanup
      exit 1
    fi
  fi

  if [[ "$counter" -eq "$valgrindcheck" ]]; then
    counter=0
    echo -n "Test $i valg: "
    memerr=`valgrind -q ../boolector "$file" 2>&1 | grep ==`
    if [[ -n "$memerr" ]]; then
      echo ""
      echo "ERROR"
      cp "$file" "$fileerror"
      echo "; valgrind error" >> "$fileerror"
      cleanup
      exit 1
    fi 
    echo "OK"
  fi

  echo ""

done
