#!/bin/bash

# ATTENTION: we use btorold2new filter as workaround for btorgen

readonly usage="*** fuzztestboolector: usage: ./fuzztestboolector [-i <id>] [-c <limit> [-n] [-r] [-s <update>] [-v <valgrindchecks>]" 
readonly covdir="./covtests/"
readonly filename="/tmp/fuzztestboolector$$"
readonly filedump="/tmp/fuzztestboolector$$dump.btor"
readonly filetmp="/tmp/fuzztestboolector$$.tmp"
readonly filecovhashes="./fuzztestboolectorhashes"
readonly filecovlock="/var/lock/testmcbtorbtorgen${PPID}lock"
readonly stdoutput="/tmp/fuzztestboolector$$boolectorstdout.tmp"
readonly lockfile="lockfile"
readonly shmfile="/dev/shm/fuzztestboolector"

function cleanup
{
  rm -f "$file"
  rm -f "$filedump"
  rm -f "$filetmp"
  rm -f "$stdoutput"
  if [[ "$covcleanup" -eq 1 ]]; then
    rm -f "$filecovhashes"
    rm -f "$filecovlock"
  fi
}


btorgen=`which btorgen`
if [[ -z "$btorgen" ]]; then
  echo "*** fuzztestboolector: can not find 'btorgen'" 1>&2
  exit 1
fi

btorgenjava=`which btorgenjava`

if [[ -z "$btorgenjava" ]]; then
  echo "*** fuzztestboolector: can not find 'btorgenjava'" 1>&2
  exit 1
fi

boolector04=`which boolector-0.4`
if [[ -z "$boolector04" ]]; then
  echo "*** fuzztestboolector: can not find 'boolector-0.4'" 1>&2
  exit 1
fi

fuzzsmtbv=`which fuzzsmtbv`
if [[ -z "$fuzzsmtbv" ]]; then
  echo "*** fuzztestboolector: can not find 'fuzzsmtbv'" 1>&2
  exit 1
fi

fuzzsmt=`which fuzzsmt`
if [[ -z "$fuzzsmt" ]]; then
  echo "*** fuzztestboolector: can not find 'fuzzsmt'" 1>&2
  exit 1
fi

i=0
valgrindcounter=0
valgrindcheck=100 # every nth testcase we check with valgrind
cov=0
covlimit=0
id=1
covtestcounter=0
covcleanup=1
crosscheck=0
stats=0
statscounter=0
update=0

while getopts "i:c:nrs:v:" o
do
  case "$o" in
  i)	id=$OPTARG;;
  c)	cov=1; covlimit=$OPTARG;;
  n)	covcleanup=0;;
  r)	crosscheck=1;;
  s)    stats=1; update=$OPTARG;;
  v)    valgrindcheck=$OPTARG;;
  [?])	echo "$usage" 1>&2; exit 1;;
  esac
done

trap 'cleanup; exit 0' SIGHUP SIGINT SIGTERM

errtxtfile=error${id}.txt

if [[ "$cov" -eq 1 ]]; then
  if [[ "$covlimit" -lt 1 ]]; then
    echo "Coverage limit must be positive" 1>&2
    exit 1
  fi

  if [[ "$covcleanup" -eq 1 ]]; then
    rm -r -f "$covdir"
    mkdir "$covdir"
    if [[ ! -e "$covdir" ]] || [[ ! -d "$covdir" ]] || \
       [[ ! -r "$covdir" ]] || [[ ! -w "$covdir" ]]; then
      echo "IO error"
      exit 1
    fi

    rm -f "$filecovhashes"
    touch "$filecovhashes"
  fi
fi


while true 
do 
  ((i++))
  ((valgrindcounter++))
  ((statscounter++))

  randomnumber=$RANDOM
  ((randomnumber %= 3))
  case $randomnumber in
  0)	uamode=uag;;
  1)	uamode=ual;;
  2)	uamode=uali;;
  esac

  randomnumber=$RANDOM
  ((randomnumber &= 1))
  if [[ "$randomnumber" -eq 0 ]]; then
    uabwref=uad
  else
    uabwref=uai
  fi

  randomnumber=$RANDOM
  ((randomnumber &= 3))
  case $randomnumber in
  0)	uaenc=uaz;;
  1)	uaenc=uao;;
  2)	uaenc=uas;;
  3)	uaenc=uac; uabwref=uad;;     # uac needs uad
  esac

  ua=$RANDOM
  ((ua &= 1))

  # when we create coverage tests,
  # we do not want to generate models
  checkmodel=$RANDOM
  ((checkmodel = checkmodel & 1 & !cov))

  fuzzer=$RANDOM
  # if we create coverage tests, we do not select 
  # fuzzsmtbv and fuzzsmt as fuzzers as they produce smt files
  if [[ $cov -eq 1 ]]; then
    ((fuzzer %= 2))
  else
    ((fuzzer %= 4))
  fi

  case $fuzzer in
    0)suffix=btor 
      file=${filename}.${suffix}
      $btorgenjava 2> /dev/null | sed -e 's,nego,redxor,g' | btorold2new > "$file";;
    1)suffix=btor 
      file=${filename}.${suffix}
      file=${filename}.${suffix}
      n=$RANDOM 
      ((n &= 1023)) 
      $btorgen -n $n 2> /dev/null | btorold2new > "$file";;
    2)suffix=smt
      file=${filename}.${suffix}
      file=${filename}.${suffix}
      v=$RANDOM
      ((v &= 15))
      # we need at least one variable
      ((v++))
      c=$RANDOM
      ((c &= 7))
      $fuzzsmtbv -v $v -c $c 2> /dev/null > "$file";;
    3)suffix=smt
      file=${filename}.${suffix}
      file=${filename}.${suffix}
      randflag=$RANDOM
      ((randflag &= 1))
      if [[ $randflag -eq 1 ]]; then
        $fuzzsmt QF_BV 2> /dev/null > "$file"
      else
        #checkmodel script does does not support bit-width > 8
        bw=$RANDOM
        ((bw &= 7))
        ((bw++))
        $fuzzsmt QF_AUFBV -Mbw $bw -Mxn 5 2> /dev/null > "$file"
      fi
  esac

  if [[ ! -s "$file" ]]; then
    echo "*** fuzztestboolector: generated file is empty"
    cleanup
    exit 1
  fi 

  for rwl in 3 2 1 0
  do
    echo -n "Test $i rwl$rwl: "

    callstring="-rwl$rwl $file"
    if [[ "$ua" -eq 1 ]]; then
      callstring="$callstring -$uamode -$uabwref -$uaenc"
    fi
    if [[ "$checkmodel" -eq 1 ]]; then
      callstring="$callstring -m"
    fi

    if [[ "$cov" -eq 1 ]]; then
      covbase=${covdir}cov_id${id}_test$covtestcounter
      stderror=${covbase}.err
    else
      stderror=/dev/null
    fi
      
    echo $callstring
    boolector $callstring 1> "$stdoutput" 2> "$stderror"
    result=`cat "$stdoutput" | head -n 1`
    echo $result
    if [[ "$rwl" -eq 3 ]]; then 
      goldenresult=$result
      if [[ "$goldenresult" != sat ]] && [[ "$goldenresult" != unsat ]]; then
	echo "ERROR"
	cp "$file" error${id}.$suffix
	echo "error: $callstring" > $errtxtfile
	cleanup
	exit 1
      fi
      if [[ "$crosscheck" -eq 1 ]]; then
        if [[ $suffix == smt ]]; then
          result=`boolector $file -de | $boolector04 2> /dev/null`
        elif [[ $suffix == btor ]]; then
          result=`$boolector04 $file 2> /dev/null`
        else
          echo "INTERNAL ERROR"
          exit 1
        fi
	if [[ "$goldenresult" != "$result" ]]; then
	  echo "ERROR"
	  cp "$file" error${id}.$suffix
	  echo "error: $callstring" > "$errtxtfile"
          echo "boolector-0.4 yields different result" >> "$errtxtfile"
          if [[ $suffix != btor ]]; then
            echo "after converting file to BTOR" >> "$errtxtfile"
          fi
	  cleanup
	  exit 1
	fi
      fi
    else
      if [[ "$goldenresult" != "$result" ]]; then
	echo "ERROR"
	cp "$file" error${id}.$suffix
	echo "error: $callstring" > "$errtxtfile"
	echo "golden result: $goldenresult" >> "$errtxtfile"
	echo "actual result: $result" >> "$errtxtfile"
	cleanup
	exit 1
      fi
    fi 

    if [[ "$cov" -eq 1 ]]; then
      if [[ ! -s "$stderror" ]]; then
	rm "$stderror"
      else
        cat "$stderror" | sort | uniq > "$filetmp"
	hashsum=`md5sum "$filetmp" | awk '{ print $1 }'`
        # synchronization for parallel usage
	( flock -x 200 
	  numcovtests=`cat "$filecovhashes" | wc -l`
	  if [[ "$numcovtests" -eq "$covlimit" ]]; then
	    exit 2
	  fi
	  if [[ `grep -c "^$hashsum" "$filecovhashes"` -eq 0 ]]; then
	    echo "$hashsum" >> "$filecovhashes"
	    exit 1
	  else
	    exit 0
	  fi 
	) 200> "$filecovlock"
	retval=$?

	if [[ "$retval" -eq 2 ]]; then
	  cleanup
	  rm "$stderror"
	  exit 0
	fi

	if [[ "$retval" -eq 1 ]]; then
	  cp "$filetmp" "$stderror"
	  callfile=${covbase}.cs
	  covtestfile=${covbase}.btor
	  echo ${callstring/" $file"/""} > "$callfile"
	  cp "$file" "$covtestfile"
	  ((covtestcounter++))
	else
	  rm "$stderror"
	fi
      fi
    fi

  done

  echo "Test $i dump: "
  boolector "$file" -de 1> "$filedump" 2> /dev/null
  result=`boolector "$filedump" 2> /dev/null`
  echo $result
  if [[ "$goldenresult" != "$result" ]]; then
    echo "ERROR"
    cp "$file" error${id}.$suffix
    echo "dump error" > "$errtxtfile"
    echo "golden result: $goldenresult" >> "$errtxtfile"
    echo "actual result: $result" >> "$errtxtfile"
    cleanup
    exit 1
  fi 

  if [[ "$checkmodel" -eq 1 ]] && [[ "$result" == sat ]] && \
     [[ "$suffix" == btor ]]; then
    modelresult=`btorcheckmodel "$file" "$stdoutput"`
    if [[ "$modelresult" != Valid ]]; then
      echo "ERROR"
      cp "$file" error${id}.$suffix
      cp "$stdoutput" "error${id}.model"
      echo "error: $callstring" > "$errtxtfile"
      cleanup
      exit 1
    fi
  fi

  if [[ "$valgrindcounter" -eq "$valgrindcheck" ]]; then
    valgrindcounter=0
    echo -n "Test $i valg: "
    memerr=`valgrind -q ../boolector "$file" 2>&1 | grep ==`
    if [[ -n "$memerr" ]]; then
      echo ""
      echo "ERROR"
      cp "$file" error${id}.$suffix
      echo "valgrind error" > "$errtxtfile"
      cleanup
      exit 1
    fi 
    echo "OK"
  fi

  if [[ "$statscounter" -eq "$update" ]]; then
    (
      flock -x 200
      result=`cat $shmfile`
      result=`echo "$result + $update" | bc`
      echo $result
      echo $result > $shmfile
    )200>"$lockfile"
    statscounter=0
  fi
  echo ""

done
