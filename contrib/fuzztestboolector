#!/bin/bash

# ATTENTION: we use btorold2new filter as workaround for btorgen

readonly usage="*** fuzztestboolector: usage: ./fuzztestboolector [-i <id>] [-c <limit> [-n] [-r] [-s <update>]]" 
readonly covdir="./covtests/"
readonly valgrindcheck=100 # every nth testcase we check with valgrind
readonly file="/tmp/fuzztestboolector$$.btor"
readonly filedump="/tmp/fuzztestboolector$$dump.btor"
readonly filetmp="/tmp/fuzztestboolector$$.tmp"
readonly filecovhashes="./fuzztestboolectorhashes"
readonly filecovlock="/var/lock/testmcbtorbtorgen${PPID}lock"
readonly stdoutput="/tmp/fuzztestboolector$$boolectorstdout.tmp"
readonly lockfile="lockfile"
readonly shmfile="/dev/shm/fuzztestboolector"

function cleanup
{
  rm -f "$file"
  rm -f "$filedump"
  rm -f "$filetmp"
  rm -f "$stdoutput"
  if [[ "$covcleanup" -eq 1 ]]; then
    rm -f "$filecovhashes"
    rm -f "$filecovlock"
  fi
}


btorgen=`which btorgen`
if [[ -z "$btorgen" ]]; then
  echo "*** fuzztestboolector: can not find 'btorgen'" 1>&2
  exit 1
fi

btorgenjava=`which btorgenjava`

if [[ -z "$btorgenjava" ]]; then
  echo "*** fuzztestboolector: can not find 'btorgenjava'" 1>&2
  exit 1
fi

boolector04=`which boolector-0.4`
if [[ -z "$boolector04" ]]; then
  echo "*** fuzztestboolector: can not find 'boolector-0.4'" 1>&2
  exit 1
fi

smtbvfuzzer=`which smtbvfuzzer`
if [[ -z "$smtbvfuzzer" ]]; then
  echo "*** fuzztestboolector: can not find 'smtbvfuzzer'" 1>&2
  exit 1
fi

i=0
valgrindcounter=0
cov=0
covlimit=0
id=1
covtestcounter=0
covcleanup=1
crosscheck=0
stats=0
statscounter=0
update=0

while getopts "i:c:nrs:" o
do
  case "$o" in
  i)	id=$OPTARG;;
  c)	cov=1; covlimit=$OPTARG;;
  n)	covcleanup=0;;
  r)	crosscheck=1;;
  s)    stats=1; update=$OPTARG;;
  [?])	echo "$usage" 1>&2; exit 1;;
  esac
done

fileerror="error${id}.btor"

trap 'cleanup; exit `ls $fileerror 2> /dev/null | wc -l`' SIGHUP SIGINT SIGTERM

if [[ "$cov" -eq 1 ]]; then
  if [[ "$covlimit" -lt 1 ]]; then
    echo "Coverage limit must be positive" 1>&2
    exit 1
  fi

  if [[ "$covcleanup" -eq 1 ]]; then
    rm -r -f "$covdir"
    mkdir "$covdir"
    if [[ ! -e "$covdir" ]] || [[ ! -d "$covdir" ]] || \
       [[ ! -r "$covdir" ]] || [[ ! -w "$covdir" ]]; then
      echo "IO error"
      exit 1
    fi

    rm -f "$filecovhashes"
    touch "$filecovhashes"
  fi
fi


while true 
do 
  ((i++))
  ((valgrindcounter++))
  ((statscounter++))

  randomnumber=$RANDOM
  ((randomnumber %= 3))
  case $randomnumber in
  0)	uamode=uag;;
  1)	uamode=ual;;
  2)	uamode=uali;;
  esac

  randomnumber=$RANDOM
  ((randomnumber &= 1))
  if [[ "$randomnumber" -eq 0 ]]; then
    uabwref=uad
  else
    uabwref=uai
  fi

  randomnumber=$RANDOM
  ((randomnumber &= 3))
  case $randomnumber in
  0)	uaenc=uaz;;
  1)	uaenc=uao;;
  2)	uaenc=uas;;
  3)	uaenc=uac; uabwref=uad;;     # uac needs uad
  esac

  ua=$RANDOM
  ((ua &= 1))

  # when we create coverage tests,
  # we do not want to generate models
  checkmodel=$RANDOM
  ((checkmodel = checkmodel & 1 & !cov))

  fuzzer=$RANDOM
  ((fuzzer %= 3))

  if [[ $fuzzer -eq 0 ]]; then
    $btorgenjava 2> /dev/null | sed -e 's,nego,redxor,g' | btorold2new > "$file"
  elif [[ $fuzzer -eq 1 ]]; then
    n=$RANDOM
    ((n &= 1023))
    $btorgen -n $n 2> /dev/null | btorold2new > "$file"
  else
    vars=$RANDOM
    ((v &= 31))
    # we need at least one variable
    ((v++))
    consts=$RANDOM
    ((c &= 15))
    $smtbvfuzzer -v $v -c $c 2> /dev/null | boolector -rwl0 -de > "$file"
  fi

  if [[ ! -s "$file" ]]; then
    echo "*** fuzztestboolector: generated file is empty"
    cleanup
    exit 1
  fi 

  for rwl in 3 2 1 0
  do
    echo -n "Test $i rwl$rwl: "

    callstring="-rwl$rwl $file"
    if [[ "$ua" -eq 1 ]]; then
      callstring="$callstring -$uamode -$uabwref -$uaenc"
    fi
    if [[ "$checkmodel" -eq 1 ]]; then
      callstring="$callstring -m"
    fi

    if [[ "$cov" -eq 1 ]]; then
      covbase=${covdir}cov_id${id}_test$covtestcounter
      stderror=${covbase}.err
    else
      stderror=/dev/null
    fi
      
    echo $callstring
    boolector $callstring 1> "$stdoutput" 2> "$stderror"
    retval=$?
    cat "$stdoutput" | head -n 1
    if [[ "$rwl" -eq 3 ]]; then 
      goldenretval=$retval
      if [[ "$goldenretval" -ne 2 ]] && [[ "$goldenretval" -ne 3 ]]; then
	echo "ERROR"
	cp "$file" "$fileerror"
	echo "; error: $callstring" >> "$fileerror"
	cleanup
	exit 1
      fi
      if [[ "$crosscheck" -eq 1 ]]; then
	$boolector04 $file &> /dev/null
	retval=$?
	if [[ $goldenretval -ne $retval ]]; then
	  echo "ERROR"
	  cp "$file" "$fileerror"
	  echo "; error: $callstring boolector-0.4 yields other result" >> "$fileerror"
	  cleanup
	  exit 1
	fi
      fi
    else
      if [[ "$retval" -ne "$goldenretval" ]]; then
	echo "ERROR"
	cp "$file" "$fileerror"
	echo "; error: $callstring" >> "$fileerror"
	cleanup
	exit 1
      fi
    fi 

    if [[ "$cov" -eq 1 ]]; then
      if [[ ! -s "$stderror" ]]; then
	rm "$stderror"
      else
        cat "$stderror" | sort | uniq > "$filetmp"
	hashsum=`md5sum "$filetmp" | awk '{ print $1 }'`
        # synchronization for parallel usage
	( flock -x 200 
	  numcovtests=`cat "$filecovhashes" | wc -l`
	  if [[ "$numcovtests" -eq "$covlimit" ]]; then
	    exit 2
	  fi
	  if [[ `grep -c "^$hashsum" "$filecovhashes"` -eq 0 ]]; then
	    echo "$hashsum" >> "$filecovhashes"
	    exit 1
	  else
	    exit 0
	  fi 
	) 200> "$filecovlock"
	returnval=$?

	if [[ "$returnval" -eq 2 ]]; then
	  cleanup
	  rm "$stderror"
	  exit 0
	fi

	if [[ "$returnval" -eq 1 ]]; then
	  cp "$filetmp" "$stderror"
	  callfile=${covbase}.cs
	  covtestfile=${covbase}.btor
	  echo ${callstring/" $file"/""} > "$callfile"
	  cp "$file" "$covtestfile"
	  ((covtestcounter++))
	else
	  rm "$stderror"
	fi
      fi
    fi

  done

  echo -n "Test $i dump: "
  boolector "$file" -de 1> "$filedump" 2> /dev/null
  boolector "$filedump" 2> /dev/null
  retval=$?
  if [[ "$retval" -ne "$goldenretval" ]]; then
    echo "ERROR"
    cp "$file" "$fileerror"
    echo "; dump error" >> "$fileerror"
    cleanup
    exit 1
  fi 

  if [[ "$checkmodel" -eq 1 ]] && [[ "$retval" -eq 2 ]]; then
    btorcheckmodel "$file" "$stdoutput"
    retval=$?
    if [[ "$retval" -ne 0 ]]; then
      echo "ERROR"
      cp "$file" "$fileerror"
      cp "$stdoutput" "${fileerror}.model"
      echo "; error: $callstring" >> "$fileerror"
      cleanup
      exit 1
    fi
  fi

  if [[ "$valgrindcounter" -eq "$valgrindcheck" ]]; then
    valgrindcounter=0
    echo -n "Test $i valg: "
    memerr=`valgrind -q ../boolector "$file" 2>&1 | grep ==`
    if [[ -n "$memerr" ]]; then
      echo ""
      echo "ERROR"
      cp "$file" "$fileerror"
      echo "; valgrind error" >> "$fileerror"
      cleanup
      exit 1
    fi 
    echo "OK"
  fi

  if [[ "$statscounter" -eq "$update" ]]; then
    (
      flock -x 200
      result=`cat $shmfile`
      result=`echo "$result + $update" | bc`
      echo $result
      echo $result > $shmfile
    )200>"$lockfile"
    statscounter=0
  fi
  echo ""

done
